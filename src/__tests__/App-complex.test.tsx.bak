import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import App from '../App';
import { searchUsers, getUserRepositories } from '../api/github';
import type { GitHubUser, GitHubRepository } from '../api/github';

// Mock the API
vi.mock('../api/github', () => ({
  searchUsers: vi.fn(),
  getUserRepositories: vi.fn(),
}));

const mockUsers: GitHubUser[] = [
  {
    id: 1,
    login: 'testuser',
    avatar_url: 'https://avatars.githubusercontent.com/u/1?v=4',
    html_url: 'https://github.com/testuser',
    public_repos: 2,
    followers: 100,
    following: 50,
    name: 'Test User',
    bio: 'A test user for testing',
  },
];

const mockRepositories: GitHubRepository[] = [
  {
    id: 1,
    name: 'test-repo-1',
    full_name: 'testuser/test-repo-1',
    description: 'First test repository',
    html_url: 'https://github.com/testuser/test-repo-1',
    stargazers_count: 5,
    forks_count: 2,
    language: 'TypeScript',
    updated_at: '2023-01-01T00:00:00Z',
    private: false,
  },
  {
    id: 2,
    name: 'test-repo-2',
    full_name: 'testuser/test-repo-2',
    description: 'Second test repository',
    html_url: 'https://github.com/testuser/test-repo-2',
    stargazers_count: 10,
    forks_count: 3,
    language: 'JavaScript',
    updated_at: '2023-02-01T00:00:00Z',
    private: true,
  },
];

describe('App Integration Tests', () => {
  const mockSearchUsers = vi.mocked(searchUsers);
  const mockGetUserRepositories = vi.mocked(getUserRepositories);

  beforeEach(() => {
    vi.clearAllMocks();
    vi.useFakeTimers();
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  it('renders the complete application', () => {
    render(<App />);

    expect(screen.getByText('GitHub Repository Explorer')).toBeInTheDocument();
    expect(screen.getByPlaceholderText('Enter username to search...')).toBeInTheDocument();
  });

  it('completes full user search and repository loading flow', async () => {
    mockSearchUsers.mockResolvedValue(mockUsers);
    mockGetUserRepositories.mockResolvedValue(mockRepositories);

    render(<App />);

    // Search for users
    const searchInput = screen.getByPlaceholderText('Enter username to search...');
    await userEvent.type(searchInput, 'testuser');
    
    // Fast-forward debounce timer
    vi.advanceTimersByTime(500);

    // Wait for search results
    await waitFor(() => {
      expect(screen.getByText('testuser')).toBeInTheDocument();
    });

    // Click on user to select
    const userCard = screen.getByRole('option', { name: /testuser/ });
    await userEvent.click(userCard);

    // Wait for repositories to load
    await waitFor(() => {
      expect(screen.getByText("testuser's Repositories (2)")).toBeInTheDocument();
      expect(screen.getByText('test-repo-1')).toBeInTheDocument();
      expect(screen.getByText('test-repo-2')).toBeInTheDocument();
    });

    // Verify API calls
    expect(mockSearchUsers).toHaveBeenCalledWith('testuser');
    expect(mockGetUserRepositories).toHaveBeenCalledWith('testuser');
  });

  it('handles search errors gracefully', async () => {
    mockSearchUsers.mockRejectedValue(new Error('Search failed'));

    render(<App />);

    const searchInput = screen.getByPlaceholderText('Enter username to search...');
    await userEvent.type(searchInput, 'testuser');
    vi.advanceTimersByTime(500);

    await waitFor(() => {
      expect(screen.getByText('Error searching users. Please try again.')).toBeInTheDocument();
    });
  });

  it('handles repository loading errors with retry functionality', async () => {
    mockSearchUsers.mockResolvedValue(mockUsers);
    mockGetUserRepositories.mockRejectedValue(new Error('Repository fetch failed'));

    render(<App />);

    // Search and select user
    const searchInput = screen.getByPlaceholderText('Enter username to search...');
    await userEvent.type(searchInput, 'testuser');
    vi.advanceTimersByTime(500);

    await waitFor(() => {
      expect(screen.getByText('testuser')).toBeInTheDocument();
    });

    const userCard = screen.getByRole('option', { name: /testuser/ });
    await userEvent.click(userCard);

    // Wait for error message
    await waitFor(() => {
      expect(screen.getByText('Failed to load repositories for testuser. Please try again.')).toBeInTheDocument();
      expect(screen.getByRole('button', { name: 'Try Again' })).toBeInTheDocument();
    });

    // Clear mock and set up successful response for retry
    vi.clearAllMocks();
    mockGetUserRepositories.mockResolvedValue(mockRepositories);

    // Click retry button
    const retryButton = screen.getByRole('button', { name: 'Try Again' });
    await userEvent.click(retryButton);

    // Wait for successful repository loading
    await waitFor(() => {
      expect(screen.getByText("testuser's Repositories (2)")).toBeInTheDocument();
    });

    expect(mockGetUserRepositories).toHaveBeenCalledWith('testuser');
  });

  it('prevents duplicate repository requests for same user', async () => {
    mockSearchUsers.mockResolvedValue(mockUsers);
    mockGetUserRepositories.mockResolvedValue(mockRepositories);

    render(<App />);

    const searchInput = screen.getByPlaceholderText('Enter username to search...');
    await userEvent.type(searchInput, 'testuser');
    vi.advanceTimersByTime(500);

    await waitFor(() => {
      expect(screen.getByText('testuser')).toBeInTheDocument();
    });

    const userCard = screen.getByRole('option', { name: /testuser/ });
    
    // Click the same user multiple times
    await userEvent.click(userCard);
    await userEvent.click(userCard);
    await userEvent.click(userCard);

    await waitFor(() => {
      expect(screen.getByText("testuser's Repositories (2)")).toBeInTheDocument();
    });

    // Should only have called getUserRepositories once
    expect(mockGetUserRepositories).toHaveBeenCalledTimes(1);
  });

  it('handles switching between different users', async () => {
    const multipleUsers: GitHubUser[] = [
      mockUsers[0],
      {
        id: 2,
        login: 'anotheruser',
        avatar_url: 'https://avatars.githubusercontent.com/u/2?v=4',
        html_url: 'https://github.com/anotheruser',
        public_repos: 3,
        followers: 50,
        following: 25,
        name: 'Another User',
      },
    ];

    const anotherUserRepos: GitHubRepository[] = [
      {
        id: 3,
        name: 'another-repo',
        full_name: 'anotheruser/another-repo',
        description: 'Another repository',
        html_url: 'https://github.com/anotheruser/another-repo',
        stargazers_count: 15,
        forks_count: 5,
        language: 'Python',
        updated_at: '2023-03-01T00:00:00Z',
        private: false,
      },
    ];

    mockSearchUsers.mockResolvedValue(multipleUsers);
    mockGetUserRepositories
      .mockResolvedValueOnce(mockRepositories) // First user
      .mockResolvedValueOnce(anotherUserRepos); // Second user

    render(<App />);

    // Search for users
    const searchInput = screen.getByPlaceholderText('Enter username to search...');
    await userEvent.type(searchInput, 'user');
    vi.advanceTimersByTime(500);

    await waitFor(() => {
      expect(screen.getByText('testuser')).toBeInTheDocument();
      expect(screen.getByText('anotheruser')).toBeInTheDocument();
    });

    // Select first user
    const firstUserCard = screen.getByRole('option', { name: /testuser/ });
    await userEvent.click(firstUserCard);

    await waitFor(() => {
      expect(screen.getByText("testuser's Repositories (2)")).toBeInTheDocument();
      expect(screen.getByText('test-repo-1')).toBeInTheDocument();
    });

    // Select second user
    const secondUserCard = screen.getByRole('option', { name: /anotheruser/ });
    await userEvent.click(secondUserCard);

    await waitFor(() => {
      expect(screen.getByText("anotheruser's Repositories (1)")).toBeInTheDocument();
      expect(screen.getByText('another-repo')).toBeInTheDocument();
      expect(screen.queryByText('test-repo-1')).not.toBeInTheDocument();
    });

    expect(mockGetUserRepositories).toHaveBeenCalledTimes(2);
    expect(mockGetUserRepositories).toHaveBeenNthCalledWith(1, 'testuser');
    expect(mockGetUserRepositories).toHaveBeenNthCalledWith(2, 'anotheruser');
  });

  it('displays loading states correctly during the full flow', async () => {
    // Mock delayed responses
    mockSearchUsers.mockImplementation(() => 
      new Promise(resolve => setTimeout(() => resolve(mockUsers), 100))
    );
    mockGetUserRepositories.mockImplementation(() =>
      new Promise(resolve => setTimeout(() => resolve(mockRepositories), 100))
    );

    render(<App />);

    const searchInput = screen.getByPlaceholderText('Enter username to search...');
    await userEvent.type(searchInput, 'testuser');
    vi.advanceTimersByTime(500);

    // Should show search loading
    expect(document.querySelector('.spinner')).toBeInTheDocument();

    // Advance time to resolve search
    vi.advanceTimersByTime(100);
    await waitFor(() => {
      expect(screen.getByText('testuser')).toBeInTheDocument();
    });

    // Click user to load repositories
    const userCard = screen.getByRole('option', { name: /testuser/ });
    await userEvent.click(userCard);

    // Should show repository loading
    await waitFor(() => {
      expect(screen.getByText('Loading repositories for testuser...')).toBeInTheDocument();
      expect(screen.getByText('Fetching repository data...')).toBeInTheDocument();
    });

    // Advance time to resolve repository loading
    vi.advanceTimersByTime(100);
    await waitFor(() => {
      expect(screen.getByText("testuser's Repositories (2)")).toBeInTheDocument();
    });
  });

  it('maintains user selection state correctly', async () => {
    mockSearchUsers.mockResolvedValue(mockUsers);
    mockGetUserRepositories.mockResolvedValue(mockRepositories);

    render(<App />);

    const searchInput = screen.getByPlaceholderText('Enter username to search...');
    await userEvent.type(searchInput, 'testuser');
    vi.advanceTimersByTime(500);

    await waitFor(() => {
      expect(screen.getByText('testuser')).toBeInTheDocument();
    });

    const userCard = screen.getByRole('option', { name: /testuser/ });
    await userEvent.click(userCard);

    await waitFor(() => {
      expect(userCard).toHaveClass('selected');
      expect(userCard).toHaveAttribute('aria-selected', 'true');
    });
  });

  it('clears search and maintains repository view', async () => {
    mockSearchUsers
      .mockResolvedValueOnce(mockUsers)
      .mockResolvedValueOnce([]); // Empty results for new search
    mockGetUserRepositories.mockResolvedValue(mockRepositories);

    render(<App />);

    // Initial search and selection
    const searchInput = screen.getByPlaceholderText('Enter username to search...');
    await userEvent.type(searchInput, 'testuser');
    vi.advanceTimersByTime(500);

    await waitFor(() => {
      expect(screen.getByText('testuser')).toBeInTheDocument();
    });

    const userCard = screen.getByRole('option', { name: /testuser/ });
    await userEvent.click(userCard);

    await waitFor(() => {
      expect(screen.getByText("testuser's Repositories (2)")).toBeInTheDocument();
    });

    // Clear search and search for something else
    await userEvent.clear(searchInput);
    await userEvent.type(searchInput, 'nonexistent');
    vi.advanceTimersByTime(500);

    await waitFor(() => {
      expect(screen.getByText('No users found for "nonexistent". Try a different search term.')).toBeInTheDocument();
    });

    // Repository view should still be visible
    expect(screen.getByText("testuser's Repositories (2)")).toBeInTheDocument();
  });
});